# 场景架构迁移说明

## 一、已实现内容

### 1. ScriptableObject 配置
- **LevelData**：单关卡配置（刷怪间隔、最大敌人数、难度倍率等）
- **LevelDatabase**：关卡库，持有 `LevelData[]`
- 菜单位置：`EggRogue → 创建 LevelDatabase 与默认关卡`

### 2. 常驻场景与引导
- **PersistentBootstrap**：挂在 `PersistentRoot` 上，Awake 时 `DontDestroyOnLoad` 并加载主菜单
- **PersistentScene**：通过 `EggRogue → 创建 PersistentScene` 自动创建并搭建结构

### 3. 场景流
- 启动 → **PersistentScene** 加载 → Bootstrap 加载 **MainMenu**
- 主菜单「开始游戏」→ **GameScene**（当前关卡 1）
- 游戏中「返回主菜单」→ **MainMenu**
- 「重新开始」→ **GameScene** 第 1 关
- **LevelManager.NextLevel()**：下一关；通关则返回主菜单

### 4. 关卡应用
- `LevelManager` 在 **GameScene** 加载后，根据当前关卡从 **LevelDatabase** 取 **LevelData**，应用到 **EnemySpawner**（刷怪间隔、最大敌人数、血量/移速倍率等）。

---

## 二、迁移步骤

### 步骤 1：创建 LevelDatabase 与关卡资源
1. 菜单：**EggRogue → 创建 LevelDatabase 与默认关卡**
2. 在 `Assets/EggRogue/Configs/` 下生成 `LevelDatabase.asset` 与 `Levels/Level_01`～`Level_20`
3. 按需在 Inspector 中调整各 **LevelData** 的数值

### 步骤 2：创建 PersistentScene
1. 菜单：**EggRogue → 创建 PersistentScene**
2. 会在 `Assets/EggRogue/Scenes/PersistentScene.unity` 创建场景，并**自动加入 Build 且置为首场景**
3. 若使用 **New Input System**，请将 `EventSystem` 上的 `StandaloneInputModule` 换成 **Input System UI Input Module**，并绑定对应 Input Actions Asset

### 步骤 3：配置 LevelManager
1. 打开 **PersistentScene**
2. 选中 **Managers/LevelManager**（脚本为 `EggRogue.LevelManager`，与 FlappyBrid 的 LevelManager 区分）
3. 将 **Level Database** 引用拖成 `Configs/LevelDatabase`（`EggRogue.LevelDatabase`）
4. 如需修改总关卡数，设置 **Max Level Count**（0 表示用 LevelDatabase 的 `levels` 长度）

### 步骤 4：清理 MainMenu 场景
1. 打开 **MainMenu**
2. **删除** 整个 **UIRoot**（含 Canvas、EventSystem、MainMenuPanel、GameHudPanel 等）
3. **删除** 场景中的 **GameManager**（若存在）
4. 只保留主菜单的**背景、装饰、灯光、相机**等视觉内容
5. 保存场景

### 步骤 5：清理 GameScene
1. 打开 **GameScene**
2. **删除** 其中的 **Canvas、EventSystem、GameHudPanel、JoystickPanel** 等 UI（若有）
3. **删除** 场景中的 **CSVConfigManager、GoldManager、GameManager** 等管理器（若存在）
4. 保留 **Player、Camera、EnemySpawner、EnemyManager、地面、灯光** 等玩法相关对象
5. **TouchInputHandler、VirtualJoystick**：若当前在 MainMenu 的 UI 下，需改为从 **PersistentScene 的 UIRoot** 引用（例如把摇杆、Config 按钮等做到 **GameHudPanel** 下，随 PersistentScene 常驻）
6. 保存场景

### 步骤 6：Build Settings
1. **File → Build Settings**
2. 确认 **PersistentScene** 为**第 0 个**场景
3. 其次为 **MainMenu**、**GameScene**
4. 保存

### 步骤 7：运行验证
1. 从 **PersistentScene** 或 **MainMenu** 启动 Play
2. 应进入主菜单 → 点击「开始游戏」→ 进入 **GameScene** → 点击「返回主菜单」→ 回到主菜单
3. 关卡配置通过 **LevelDatabase / LevelData** 生效，可在 **Level_01** 等资源上改数后重进游戏验证

---

## 三、PersistentScene 结构（创建后）

```
PersistentRoot (PersistentBootstrap)
├── Managers
│   ├── GameManager
│   ├── UIManager
│   ├── GoldManager
│   ├── CSVConfigManager
│   └── LevelManager
└── UIRoot
    ├── Canvas
    │   ├── MainMenuPanel (含 StartGameButton)
    │   └── GameHudPanel (含 ReturnToMenuButton)
    └── EventSystem
```

- **UIRoot** 随 **PersistentRoot** 常驻，主菜单与游戏场景切换时不会被卸载。
- 若后续在 **GameHudPanel** 下加摇杆、Config 按钮等，也随 PersistentScene 常驻，需在 **TouchInputHandler** 等处引用 **UIRoot** 下对应节点。

---

## 四、关卡与 LevelManager

- **LevelManager** 常驻 **PersistentScene**，持有 **LevelDatabase** 引用。
- **GameScene** 加载后，**LevelManager** 根据 **CurrentLevel** 取 **LevelData**，对 **EnemySpawner** 调用 **ApplyLevelData**、**ResetForLevel**，并设置 `spawnInterval`、`maxAliveEnemies`、`randomOffsetRadius`。
- 敌人生成时，若存在 **LevelData**，则按 **enemyHealthMultiplier**、**enemyMoveSpeedMultiplier** 在 CSV 基础上做倍率计算。
- 通关或进入下一关的逻辑在业务层调用 **LevelManager.NextLevel()**；若当前已为最后一关，则 **LevelManager** 会调用 **GameManager.ReturnToMenu()**。

---

## 五、常见问题

1. **运行后直接进 MainMenu，没有先看到 PersistentScene？**  
   - 正常。Bootstrap 在 **PersistentScene** 加载后立即加载 **MainMenu**，首帧即完成切换。

2. **UI 或按钮找不到？**  
   - 确认 **UIManager** 的 **mainMenuPanel**、**gameHudPanel** 已正确绑定（创建 PersistentScene 时已自动绑定占位面板与按钮）。

3. **关卡配置没生效？**  
   - 确认 **LevelManager** 的 **Level Database** 已指定 **LevelDatabase**。  
   - 确认 **GameScene** 中存在 **EnemySpawner**，且 **Enemy Prefab**、**Spawn Points** 等已配置。

4. **摇杆、Config 按钮在 GameScene？**  
   - 按本节「步骤 5」将相关 UI 迁到 **PersistentScene** 的 **GameHudPanel**（或 UIRoot 下），并更新 **TouchInputHandler**、**ConfigUpdateButton** 等的引用。

完成以上迁移后，即形成 **PersistentScene（UI + 管理器）→ MainMenu / GameScene** 的分层场景架构，关卡配置由 **LevelDatabase / LevelData** 驱动。
