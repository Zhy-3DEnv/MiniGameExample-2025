# 场景管理规划方案

## 当前问题分析

### 问题1：UI 和角色分离在不同场景
- **MainMenu 场景**：包含 UI（MainMenuPanel、GameHudPanel）
- **GameScene 场景**：包含角色、敌人、相机等
- **问题**：调整时需要频繁切换场景，非常不方便

### 问题2：关卡管理不清晰
- 游戏有 20 个关卡的概念
- 但当前只有一个 `GameScene`
- 如何区分不同关卡？如何切换关卡？

### 问题3：场景职责混乱
- UI 应该常驻还是按需加载？
- 角色应该放在哪个场景？
- 关卡数据如何管理？

---

## 推荐方案：分层场景架构

### 核心思路

**将场景分为 3 层**：
1. **常驻层（Persistent）**：UI、管理器等，永不销毁
2. **功能层（Functional）**：主菜单、游戏场景等，按需加载
3. **数据层（Data）**：关卡配置、角色配置等，通过 ScriptableObject/CSV 管理

---

## 场景结构设计

### 方案A：UI 常驻 + 场景切换（推荐）

#### 场景列表

1. **PersistentScene（常驻场景）**
   - **职责**：核心系统，永不销毁
   - **包含内容**：
     - `GameManager`（单例，DontDestroyOnLoad）
     - `UIManager`（单例，DontDestroyOnLoad）
     - `UIRoot`（Canvas、EventSystem，DontDestroyOnLoad）
     - `GoldManager`、`CSVConfigManager` 等管理器
   - **特点**：
     - 只在游戏启动时加载一次
     - 后续场景切换时，这些对象始终存在
     - UI 可以在所有场景中显示

2. **MainMenuScene（主菜单场景）**
   - **职责**：主菜单界面
   - **包含内容**：
     - 背景模型/图片
     - 菜单装饰物
     - 灯光、相机（可选，用于展示角色模型）
   - **特点**：
     - 不包含 UI（UI 在 PersistentScene）
     - 只包含视觉元素
     - 进入游戏时卸载

3. **GameScene（游戏场景模板）**
   - **职责**：游戏玩法场景
   - **包含内容**：
     - 角色（Player）
     - 相机（CameraFollow）
     - 灯光（Light）
     - 地面/环境（Ground、Environment）
     - 敌人生成器（EnemySpawner）
     - 关卡管理器（LevelManager）
   - **特点**：
     - 作为所有关卡的基础模板
     - 关卡数据通过 ScriptableObject/CSV 动态加载
     - 切换关卡时：重新加载场景 或 重置场景状态

#### 工作流程

```
游戏启动
  ↓
加载 PersistentScene（常驻）
  ↓
加载 MainMenuScene
  ↓ [点击开始游戏]
卸载 MainMenuScene
  ↓
加载 GameScene（关卡1）
  ↓ [完成关卡1]
卸载并重新加载 GameScene（关卡2）
  ↓ [完成关卡2]
...
  ↓ [完成关卡20]
卸载 GameScene
  ↓
加载 MainMenuScene（结算界面）
```

#### 优势

✅ **UI 常驻**：所有场景都能访问 UI，调整方便  
✅ **职责清晰**：每个场景职责单一  
✅ **易于调试**：可以在 PersistentScene 中直接调整 UI  
✅ **扩展性好**：后续添加新场景不影响 UI  

#### 劣势

⚠️ **需要管理场景加载顺序**：确保 PersistentScene 先加载  
⚠️ **UI 和场景分离**：需要确保 UI 在所有场景中正确显示  

---

### 方案B：单场景 + 动态切换（备选）

#### 场景列表

1. **MainScene（主场景）**
   - **职责**：包含所有内容
   - **包含内容**：
     - UI Root（常驻）
     - 主菜单区域（GameObject，可启用/禁用）
     - 游戏区域（GameObject，可启用/禁用）
     - 所有管理器

2. **关卡数据（ScriptableObject/CSV）**
   - 关卡配置数据
   - 通过 `LevelManager` 动态加载

#### 工作流程

```
游戏启动
  ↓
加载 MainScene
  ↓
启用 MainMenu 区域，禁用 Game 区域
  ↓ [点击开始游戏]
禁用 MainMenu 区域，启用 Game 区域
  ↓
加载关卡1数据
  ↓ [完成关卡1]
加载关卡2数据（重置场景）
  ↓
...
```

#### 优势

✅ **简单直接**：只有一个场景，不需要管理场景切换  
✅ **调试方便**：所有内容都在一个场景中  

#### 劣势

⚠️ **场景文件会很大**：所有内容都在一个场景  
⚠️ **加载时间长**：即使不需要的内容也会加载  
⚠️ **不够灵活**：后续添加新场景需要修改主场景  

---

## 推荐方案：方案A（UI 常驻 + 场景切换）

### 详细设计

#### 1. PersistentScene 结构

```
PersistentScene
├── Managers（空物体）
│   ├── GameManager（单例）
│   ├── UIManager（单例）
│   ├── GoldManager（单例）
│   ├── CSVConfigManager（单例）
│   └── LevelManager（单例，管理关卡）
├── UIRoot（Canvas，DontDestroyOnLoad）
│   ├── Canvas（CanvasScaler、GraphicRaycaster）
│   ├── MainMenuPanel（默认隐藏）
│   ├── GameHudPanel（默认隐藏）
│   ├── PausePanel（默认隐藏）
│   └── ResultPanel（默认隐藏）
└── EventSystem（DontDestroyOnLoad）
```

#### 2. MainMenuScene 结构

```
MainMenuScene
├── Background（背景）
├── Camera（可选，用于展示）
└── DecorativeObjects（装饰物）
```

#### 3. GameScene 结构

```
GameScene
├── Player（角色）
│   ├── CharacterController
│   ├── PlayerCombatController
│   └── Health
├── Camera（相机）
│   └── CameraFollow
├── Environment（环境）
│   ├── Ground（地面）
│   └── Lighting（灯光）
├── Gameplay（游戏逻辑）
│   ├── EnemySpawner（敌人生成器）
│   ├── EnemyManager（敌人管理器）
│   └── LevelController（关卡控制器）
└── Managers（场景本地管理器）
    └── SceneGameManager（场景游戏逻辑）
```

---

## 关卡管理设计

### 关卡数据存储

**方案1：ScriptableObject（推荐）**
```csharp
[CreateAssetMenu]
public class LevelData : ScriptableObject
{
    public int levelNumber;
    public string levelName;
    public int enemyCount;
    public float spawnRate;
    public float difficulty;
    // ... 其他关卡配置
}
```

**方案2：CSV（与现有系统一致）**
```csv
Level,EnemyCount,SpawnRate,Difficulty
1,10,2.0,1.0
2,15,2.5,1.2
...
```

### 关卡切换流程

```csharp
// LevelManager.cs
public class LevelManager : MonoBehaviour
{
    private int currentLevel = 1;
    
    public void LoadLevel(int levelNumber)
    {
        currentLevel = levelNumber;
        
        // 方案A：重新加载场景
        SceneManager.LoadScene("GameScene");
        
        // 方案B：重置场景状态（不重新加载）
        ResetGameScene();
        ApplyLevelData(levelNumber);
    }
    
    public void NextLevel()
    {
        if (currentLevel < 20)
        {
            LoadLevel(currentLevel + 1);
        }
        else
        {
            // 完成所有关卡
            GameManager.Instance.ReturnToMenu();
        }
    }
}
```

---

## 迁移步骤建议

### 阶段1：创建 PersistentScene

1. 创建新场景 `PersistentScene`
2. 将 `UIRoot`（Canvas、EventSystem）移动到 `PersistentScene`
3. 将所有管理器（GameManager、UIManager 等）移动到 `PersistentScene`
4. 设置所有需要常驻的对象为 `DontDestroyOnLoad`
5. 修改 `GameManager`，确保 `PersistentScene` 先加载

### 阶段2：清理 MainMenuScene

1. 从 `MainMenuScene` 移除所有 UI（UI 已在 PersistentScene）
2. 保留背景、装饰物等视觉元素
3. 确保场景可以正常显示（UI 会从 PersistentScene 显示）

### 阶段3：清理 GameScene

1. 确保 `GameScene` 不包含 UI
2. 确保 `GameScene` 不包含管理器（管理器在 PersistentScene）
3. 只保留游戏玩法相关的内容

### 阶段4：实现关卡系统

1. 创建 `LevelData` ScriptableObject 或 CSV
2. 创建 `LevelManager` 管理关卡切换
3. 修改 `GameManager` 支持关卡切换

---

## 调试建议

### 问题：如何同时看到 UI 和角色？

**解决方案**：
1. 在 Unity Editor 中，可以同时打开多个场景
2. 打开 `PersistentScene`（只读模式）
3. 打开 `GameScene`（可编辑模式）
4. 这样可以在 GameScene 中调整角色，同时看到 PersistentScene 的 UI

### 问题：如何快速测试？

**解决方案**：
1. 设置 `PersistentScene` 为启动场景
2. 在 `GameManager` 中添加调试选项：直接跳转到指定关卡
3. 使用 Unity 的 `Play Mode` 选项：`Enter Play Mode Options` → 禁用 `Reload Scene`

---

## 总结

### 推荐架构

```
PersistentScene（常驻）
  ├── UI 系统
  └── 管理器系统

MainMenuScene（按需加载）
  └── 主菜单视觉元素

GameScene（按需加载）
  └── 游戏玩法内容
  └── 关卡数据（动态加载）
```

### 核心原则

1. **UI 常驻**：UI 在 PersistentScene，所有场景都能访问
2. **场景职责单一**：每个场景只负责自己的内容
3. **数据驱动**：关卡数据通过 ScriptableObject/CSV 管理
4. **易于调试**：可以在一个场景中调整，同时看到其他场景的内容

### 优势

✅ **调整方便**：UI 和角色可以在不同场景中同时查看  
✅ **职责清晰**：每个场景职责单一，易于维护  
✅ **扩展性好**：后续添加新场景不影响现有系统  
✅ **性能优化**：按需加载场景，减少内存占用  

---

完成这个架构后，你就可以：
1. 在 `PersistentScene` 中调整 UI
2. 在 `GameScene` 中调整角色和游戏逻辑
3. 两者互不干扰，同时可见 ✅
